---
question: "pipex 프로젝트에서 fork()와 pipe()를 사용한 이유와 구현 시 가장 어려웠던 점은?"
shortAnswer: "fork()는 자식 프로세스를 생성하여 명령어를 독립적으로 실행하기 위해, pipe()는 프로세스 간 데이터 스트림을 연결하기 위해 사용했습니다. 가장 어려웠던 점은 파일 디스크립터 관리와 데드락 방지였으며, dup2()로 표준 입출력을 리다이렉션하고 사용하지 않는 FD를 즉시 닫아 해결했습니다."
---

## 상세 답변

### fork()와 pipe() 사용 이유

**fork() 사용 이유**
- 각 명령어를 독립적인 프로세스에서 실행하기 위함
- 부모 프로세스는 자식 프로세스를 관리하고 waitpid()로 종료를 대기
- 실제 쉘의 파이프라인 동작을 구현하기 위한 필수 요소

**pipe() 사용 이유**
- 첫 번째 명령어의 출력을 두 번째 명령어의 입력으로 연결
- 읽기/쓰기 파일 디스크립터 쌍을 생성하여 IPC(프로세스 간 통신) 구현
- 데이터가 메모리를 통해 직접 전달되어 효율적

### 구현 시 어려웠던 점

#### 1. 파일 디스크립터 관리
**문제**: 파이프의 읽기/쓰기 끝단을 적절히 닫지 않으면 데드락 발생
**해결**: 
- 각 프로세스에서 사용하지 않는 FD를 즉시 close()
- dup2() 후 원본 FD도 닫아 리소스 누수 방지

#### 2. 프로세스 동기화
**문제**: 자식 프로세스가 종료되지 않으면 좀비 프로세스 발생
**해결**: 
- 부모 프로세스에서 waitpid()로 명시적 대기
- 모든 자식 프로세스의 종료 상태 확인

#### 3. 에러 처리
**문제**: 명령어 실행 실패, 파일 권한 부재 등 다양한 예외 상황
**해결**:
- 모든 시스템 콜의 반환값 체크
- perror()와 strerror()로 상세한 에러 메시지 제공

### 기술적 성과

- Bash 쉘과 diff 비교 시 100% 일치하는 출력
- Valgrind로 메모리 누수 0 확인
- 42 Norm 코딩 표준 준수 (함수당 25줄 제한)

### 학습 포인트

이 프로젝트를 통해 운영체제의 프로세스 생명주기, 파일 디스크립터 관리, IPC 메커니즘을 실질적으로 이해하게 되었습니다.
