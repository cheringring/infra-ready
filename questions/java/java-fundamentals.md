---
question: "⭐ Java 프로그래밍 언어의 기본 개념과 객체지향 프로그래밍 원리, 그리고 Java의 핵심 특징들을 설명해주세요."
shortAnswer: "Java는 객체지향 프로그래밍 언어로 플랫폼 독립성(JVM), 자동 메모리 관리(GC), 강타입 시스템을 특징으로 합니다. 캡슐화, 상속, 다형성, 추상화의 OOP 원리를 지원하며, 컬렉션 프레임워크와 예외 처리 메커니즘을 제공합니다."
shortAnswer: "Java는 객체지향 프로그래밍 언어로 플랫폼 독립성(JVM), 자동 메모리 관리(GC), 강타입 시스템을 특징으로 합니다. 캡슐화, 상속, 다형성, 추상화의 OOP 원리를 지원하며, 컬렉션 프레임워크와 예외 처리 메커니즘을 제공합니다."
---

# Java 기초 개념

## Java 언어 개요

### Java의 특징
#### 플랫폼 독립성:
- **"Write Once, Run Anywhere"**: 한 번 작성하면 어디서나 실행
- **JVM (Java Virtual Machine)**: 바이트코드를 각 플랫폼에 맞게 실행
- **바이트코드**: `.java` → `.class` 파일로 컴파일된 중간 코드
- **크로스 플랫폼**: Windows, Linux, macOS에서 동일한 코드 실행

#### 객체지향 프로그래밍:
- **순수 객체지향**: 모든 것이 객체 (기본 타입 제외)
- **클래스 기반**: 클래스를 통한 객체 생성
- **캡슐화**: 데이터와 메서드를 하나로 묶음
- **상속**: 기존 클래스의 특성을 물려받음
- **다형성**: 하나의 인터페이스로 다양한 구현
- **추상화**: 복잡한 구현을 숨기고 인터페이스만 제공

#### 메모리 관리:
- **자동 메모리 관리**: 개발자가 직접 메모리 할당/해제 불필요
- **가비지 컬렉션**: 사용하지 않는 객체 자동 정리
- **메모리 안전성**: 포인터 연산 없음, 배열 경계 검사
- **메모리 누수 방지**: GC를 통한 자동 메모리 회수

#### 강타입 시스템:
- **정적 타입**: 컴파일 시점에 타입 검사
- **타입 안전성**: 런타임 타입 오류 방지
- **명시적 타입 선언**: 변수 선언 시 타입 명시 필요
- **타입 변환**: 명시적/암시적 타입 변환 규칙

## 데이터 타입과 변수

### 기본 데이터 타입 (Primitive Types)
#### 정수형:
- **`byte`**: 8비트, -128 ~ 127
- **`short`**: 16비트, -32,768 ~ 32,767
- **`int`**: 32비트, -2³¹ ~ 2³¹-1 (기본 정수형)
- **`long`**: 64비트, -2⁶³ ~ 2⁶³-1 (L 접미사)

#### 실수형:
- **`float`**: 32비트 단정밀도 (f 접미사)
- **`double`**: 64비트 배정밀도 (기본 실수형)

#### 기타:
- **`boolean`**: true/false (1비트 논리적 크기)
- **`char`**: 16비트 유니코드 문자

### 참조 데이터 타입 (Reference Types)
#### 클래스 타입:
- **String**: 문자열 클래스 (불변 객체)
- **사용자 정의 클래스**: 개발자가 만든 클래스
- **래퍼 클래스**: Integer, Double, Boolean 등

#### 배열 타입:
- **1차원 배열**: `int[] arr = new int[5]`
- **다차원 배열**: `int[][] matrix = new int[3][4]`
- **배열 초기화**: `{1, 2, 3}` 또는 `new int[]{1, 2, 3}`

#### 인터페이스 타입:
- **인터페이스 참조**: 구현 객체를 가리키는 참조
- **다형성**: 하나의 인터페이스로 여러 구현체 참조

### 변수와 상수
#### 변수 선언:
- **지역 변수**: 메서드 내부에서 선언
- **인스턴스 변수**: 클래스 내부, 메서드 외부에서 선언
- **클래스 변수**: `static` 키워드로 선언
- **매개변수**: 메서드 파라미터

#### 상수 선언:
- **`final`**: 한 번 초기화 후 변경 불가
- **`static final`**: 클래스 상수 (컴파일 타임 상수)
- **명명 규칙**: 대문자와 언더스코어 (CONSTANT_NAME)

## 객체지향 프로그래밍 (OOP)

### 클래스와 객체
#### 클래스 정의:
- **클래스**: 객체를 생성하기 위한 템플릿/설계도
- **필드**: 객체의 상태를 나타내는 변수
- **메서드**: 객체의 행동을 나타내는 함수
- **생성자**: 객체 초기화를 위한 특별한 메서드

#### 객체 생성:
- **`new` 키워드**: 힙 메모리에 객체 생성
- **참조 변수**: 객체의 메모리 주소를 저장
- **초기화**: 생성자를 통한 객체 초기 상태 설정
- **가비지 컬렉션**: 참조되지 않는 객체 자동 정리

### 캡슐화 (Encapsulation)
#### 접근 제어자:
- **`private`**: 같은 클래스 내에서만 접근 가능
- **`protected`**: 같은 패키지 또는 상속받은 클래스에서 접근
- **`public`**: 모든 곳에서 접근 가능
- **`default`**: 같은 패키지 내에서만 접근 가능

#### 정보 은닉:
- **데이터 보호**: 외부에서 직접 접근 차단
- **Getter/Setter**: 메서드를 통한 안전한 데이터 접근
- **유효성 검사**: Setter에서 입력값 검증
- **내부 구현 숨김**: 인터페이스만 공개

### 상속 (Inheritance)
#### 상속 관계:
- **`extends` 키워드**: 클래스 상속
- **부모 클래스**: 상위 클래스, 슈퍼 클래스
- **자식 클래스**: 하위 클래스, 서브 클래스
- **단일 상속**: Java는 클래스 단일 상속만 지원

#### 메서드 오버라이딩:
- **`@Override` 어노테이션**: 메서드 재정의 명시
- **동적 바인딩**: 런타임에 실제 객체 타입에 따라 메서드 호출
- **`super` 키워드**: 부모 클래스의 메서드/생성자 호출
- **접근 제어**: 오버라이딩 시 접근 범위 확장만 가능

### 다형성 (Polymorphism)
#### 메서드 오버로딩:
- **같은 이름, 다른 매개변수**: 매개변수 타입/개수가 다른 메서드
- **컴파일 타임 다형성**: 컴파일 시점에 호출할 메서드 결정
- **생성자 오버로딩**: 다양한 방식으로 객체 초기화

#### 런타임 다형성:
- **상위 타입 참조**: 부모 클래스 타입으로 자식 객체 참조
- **동적 메서드 디스패치**: 실행 시점에 실제 객체 타입에 따라 메서드 호출
- **`instanceof` 연산자**: 객체의 실제 타입 확인
- **타입 캐스팅**: 업캐스팅(자동), 다운캐스팅(명시적)

### 추상화 (Abstraction)
#### 추상 클래스:
- **`abstract` 키워드**: 추상 클래스 선언
- **추상 메서드**: 구현이 없는 메서드 (자식 클래스에서 구현 필수)
- **일반 메서드**: 구현된 메서드도 포함 가능
- **인스턴스 생성 불가**: 직접 객체 생성 불가능

#### 인터페이스:
- **`interface` 키워드**: 인터페이스 선언
- **추상 메서드**: 기본적으로 모든 메서드가 추상 메서드
- **상수**: `public static final` 상수만 선언 가능
- **다중 구현**: 여러 인터페이스 동시 구현 가능
- **`implements` 키워드**: 인터페이스 구현

## 컬렉션 프레임워크

### List 인터페이스
#### ArrayList:
- **동적 배열**: 크기가 자동으로 조절되는 배열
- **인덱스 접근**: `get(index)`, `set(index, element)`
- **순서 보장**: 삽입 순서 유지
- **중복 허용**: 동일한 요소 여러 개 저장 가능
- **성능**: 조회 O(1), 삽입/삭제 O(n)

#### LinkedList:
- **이중 연결 리스트**: 노드들이 연결된 구조
- **삽입/삭제**: 중간 삽입/삭제가 빠름 O(1)
- **순차 접근**: 인덱스 접근이 느림 O(n)
- **메모리**: 포인터 저장으로 추가 메모리 사용

### Set 인터페이스
#### HashSet:
- **중복 제거**: 동일한 요소 하나만 저장
- **해시 테이블**: 빠른 검색 성능 O(1)
- **순서 없음**: 삽입 순서 보장하지 않음
- **null 허용**: null 값 하나 저장 가능

#### TreeSet:
- **정렬된 집합**: 자동으로 정렬된 상태 유지
- **이진 검색 트리**: Red-Black Tree 구조
- **성능**: 삽입/삭제/검색 O(log n)
- **Comparable/Comparator**: 정렬 기준 제공 필요

### Map 인터페이스
#### HashMap:
- **키-값 쌍**: Key-Value 형태로 데이터 저장
- **빠른 검색**: O(1) 평균 성능
- **중복 키 불허**: 동일한 키는 하나의 값만 매핑
- **null 허용**: 키와 값 모두 null 가능

#### TreeMap:
- **정렬된 맵**: 키를 기준으로 자동 정렬
- **이진 검색 트리**: Red-Black Tree 구조
- **성능**: O(log n) 성능
- **NavigableMap**: 범위 검색 기능 제공

## 예외 처리 (Exception Handling)

### 예외 계층 구조
#### Throwable 클래스:
- **Error**: 시스템 레벨 오류 (OutOfMemoryError 등)
- **Exception**: 프로그램에서 처리 가능한 예외
- **RuntimeException**: 실행 시점 예외 (Unchecked Exception)
- **기타 Exception**: 컴파일 시점 예외 (Checked Exception)

#### Checked vs Unchecked Exception:
- **Checked Exception**: 컴파일 시점에 처리 강제 (IOException 등)
- **Unchecked Exception**: 처리 선택적 (NullPointerException 등)
- **Error**: 일반적으로 처리하지 않음

### 예외 처리 구문
#### try-catch-finally:
- **`try` 블록**: 예외가 발생할 수 있는 코드
- **`catch` 블록**: 예외 처리 코드
- **`finally` 블록**: 항상 실행되는 정리 코드
- **다중 catch**: 여러 예외 타입 개별 처리

#### try-with-resources:
- **자동 리소스 관리**: AutoCloseable 리소스 자동 해제
- **Java 7 이상**: 간결한 리소스 관리 구문
- **예외 억제**: 리소스 해제 시 발생한 예외 억제

#### throw와 throws:
- **`throw`**: 명시적으로 예외 발생
- **`throws`**: 메서드에서 발생할 수 있는 예외 선언
- **예외 전파**: 호출자에게 예외 처리 책임 전가

## Java 8+ 주요 기능

### 람다 표현식 (Lambda Expression)
#### 함수형 인터페이스:
- **단일 추상 메서드**: 하나의 추상 메서드만 가진 인터페이스
- **`@FunctionalInterface`**: 함수형 인터페이스 명시
- **기본 함수형 인터페이스**: Predicate, Function, Consumer, Supplier

#### 람다 문법:
- **기본 형태**: `(parameters) -> expression`
- **블록 형태**: `(parameters) -> { statements; }`
- **타입 추론**: 컴파일러가 매개변수 타입 추론
- **메서드 참조**: `ClassName::methodName`

### 스트림 API (Stream API)
#### 스트림 특징:
- **함수형 프로그래밍**: 선언적 프로그래밍 스타일
- **지연 연산**: 터미널 연산 시점에 실제 처리
- **불변성**: 원본 데이터 변경하지 않음
- **병렬 처리**: `parallelStream()` 지원

#### 스트림 연산:
- **중간 연산**: `filter()`, `map()`, `sorted()` 등
- **터미널 연산**: `collect()`, `forEach()`, `reduce()` 등
- **단축 연산**: `findFirst()`, `anyMatch()` 등

### Optional 클래스
#### Null 안전성:
- **NullPointerException 방지**: null 체크 강제
- **명시적 null 처리**: 값의 존재/부재 명확히 표현
- **함수형 스타일**: 체이닝을 통한 안전한 처리

#### Optional 메서드:
- **`of()`**: null이 아닌 값으로 Optional 생성
- **`ofNullable()`**: null일 수 있는 값으로 Optional 생성
- **`isPresent()`**: 값 존재 여부 확인
- **`orElse()`**: 값이 없을 때 기본값 반환
- **`map()`**: 값이 있을 때 변환 함수 적용

## 면접에서 어필할 포인트

### 1. 기본 개념 숙지
**"Java의 플랫폼 독립성과 JVM의 역할, 그리고 자동 메모리 관리를 통한 안전성을 이해하고 있습니다."**

### 2. 객체지향 프로그래밍 이해
**"캡슐화, 상속, 다형성, 추상화의 OOP 원리를 실제 코드에서 적용하여 유지보수성 높은 설계를 할 수 있습니다."**

### 3. 컬렉션 프레임워크 활용
**"ArrayList, HashMap 등 적절한 자료구조를 선택하여 성능을 최적화하고, 스트림 API로 함수형 프로그래밍을 적용할 수 있습니다."**

### 4. 예외 처리 능력
**"Checked/Unchecked Exception을 구분하여 적절한 예외 처리를 하고, try-with-resources로 리소스를 안전하게 관리할 수 있습니다."**

### 5. 모던 Java 기능 활용
**"Java 8의 람다 표현식과 스트림 API, Optional을 활용하여 간결하고 안전한 코드를 작성할 수 있습니다."**

### 6. 포트폴리오 연결
**"데이터 사이언스 부트캠프에서 Java로 백엔드 API를 개발했고, 42 이노베이션 아카데미에서 시스템 프로그래밍 기초를 익혀 메모리 관리에 대한 이해도를 높였습니다."**

이러한 Java 기초 지식이 **포인트아이의 엔터프라이즈 Java 개발**에 직접 활용될 수 있음을 강조하세요! 🚀
